#include <stdio.h>#include <stdlib.h>#include <string.h>#include <ctype.h>#include <math.h>#define BUFFER_SIZE 1024#define MAX_RATE 4#define MEMORY_ALLOCATION_ERROR  (-1)typedef union {	int int_data;	char char_data;	// ... other primitive types used	void *ptr_data;} data_union;typedef struct ht_element {	struct ht_element *next;	data_union data;} ht_element;typedef void (*DataFp)(data_union);typedef void (*DataPFp)(data_union*);typedef int (*CompareDataFp)(data_union, data_union);typedef size_t (*HashFp)(data_union, size_t);typedef data_union (*CreateDataFp)(void*);typedef struct {	size_t size;	size_t no_elements;	ht_element *ht;	DataFp dump_data;	CreateDataFp create_data;	DataFp free_data;	CompareDataFp compare_data;	HashFp hash_function;	DataPFp modify_data;} hash_table;// ---------------------- functions to implement// initialize table fieldsvoid init_ht(hash_table *p_table, size_t size, DataFp dump_data, CreateDataFp create_data,		 DataFp free_data, CompareDataFp compare_data, HashFp hash_function, DataPFp modify_data) {    p_table->size = size;    p_table->no_elements = 0;    p_table->ht = malloc(sizeof(ht_element)*size);    for (int i=0; i<size; i++){        p_table->ht[i].next = NULL;    }    p_table->dump_data = dump_data;    p_table->create_data = create_data;    p_table->free_data = free_data;    p_table->compare_data = compare_data;    p_table->hash_function = hash_function;    p_table->modify_data = modify_data;}// print elements of the list with hash nvoid dump_list(const hash_table* p_table, size_t n) {    ht_element *p = p_table->ht+n;    p = p->next;    while (p != NULL) {        p_table->dump_data(p->data);        p = p->next;    }    //p_table->dump_data(p->data);}// Free element pointed by data_union using free_data() functionvoid free_element(DataFp free_data, ht_element *to_delete) {    if (free_data != NULL)        free_data(to_delete->data);}// free all elements from the table (and the table itself)void free_table(hash_table* p_table) {    for (int i=0; i<p_table->size; i++){        ht_element *p = p_table->ht+i;        p=p->next;        while (p != NULL) {            ht_element *to_del = p;            p = p->next;            free_element(p_table->free_data, to_del);            free(to_del);        }    }    free(p_table->ht);}// calculate hash function for integer ksize_t hash_base(int k, size_t size) {	static const double c = 0.618033988; // (sqrt(5.) â€“ 1) / 2.;	double tmp = k * c;	return (size_t)floor((double)size * (tmp - floor(tmp)));}void rehash(hash_table *p_table) {    hash_table new_table;    init_ht(&new_table, 2*p_table->size, p_table->dump_data, p_table->create_data,            p_table->free_data, p_table->compare_data, p_table->hash_function, p_table->modify_data);    new_table.no_elements = p_table->no_elements;    for (int i=0; i<new_table.size; i++){        new_table.ht[i].next = NULL;    }    for (int i=0; i<p_table->size; i++){        ht_element *p = p_table->ht+i;        p = p->next;        while (p != NULL) {            size_t index = new_table.hash_function(p->data, new_table.size);            ht_element *to_move = p;            p = p->next;            to_move->next = new_table.ht[index].next;            new_table.ht[index].next = to_move;        }    }    memcpy(p_table, &new_table, sizeof(hash_table));}// find element; return pointer to previousht_element *find_previous(hash_table *p_table, data_union data) {    size_t index = p_table->hash_function(data, p_table->size);    ht_element *p = p_table->ht+index;    ht_element *q = p;    p=p->next;    while (p != NULL){        if (p_table->compare_data(p->data, data) == 0){            return q;        }        q = p;        p = p->next;    }    return q;}// return pointer to element with given valueht_element *get_element(hash_table *p_table, data_union *data) {    size_t index = p_table->hash_function(*data, p_table->size);    ht_element *p = p_table->ht+index;    p = p->next;    while (p != NULL) {        if (p_table->compare_data(p->data, *data) == 0)            return p;        p = p->next;    }    return NULL;}// insert elementvoid insert_element(hash_table *p_table, data_union *data) {    ht_element *check = get_element(p_table, data);    if (check != NULL) {        if (p_table->modify_data != NULL) {            p_table->modify_data(&check->data);            p_table->free_data(*data);        }        return;    }    size_t index = p_table->hash_function(*data, p_table->size);    ht_element *p = p_table->ht+index;    ht_element *new = malloc(sizeof(ht_element));    new->next = p->next;    new->data = *data;    p->next = new;    p_table->no_elements++;    if (p_table->no_elements/p_table->size > MAX_RATE) {        rehash(p_table);    }}// remove elementvoid remove_element(hash_table *p_table, data_union data) {    ht_element *to_delete = get_element(p_table, &data);    ht_element *prev = find_previous(p_table, data);    if (to_delete == NULL)        return;    prev->next = to_delete->next;    free_element(p_table->free_data, to_delete);    p_table->no_elements--;    free(to_delete);}// type-specific definitions// int elementsize_t hash_int(data_union data, size_t size) {	return hash_base(data.int_data, size);}void dump_int(data_union data) {    printf("%d ", data.int_data);}int cmp_int(data_union a, data_union b) {    return a.int_data - b.int_data;}data_union create_int(void* value) {    data_union data;    int val = 0;    scanf("%d", &val);    data.int_data = val;    return data;}// char elementsize_t hash_char(data_union data, size_t size) {	return hash_base((int)data.char_data, size);}void dump_char(data_union data) {    printf("%c ", data.char_data);}int cmp_char(data_union a, data_union b) {    return a.char_data - b.char_data;}data_union create_char(void* value) {    data_union data;    char val;    scanf(" %c", &val);    data.char_data = val;    return data;}// Word elementtypedef struct DataWord {	char *word;	int counter;} DataWord;void dump_word(data_union data) {    DataWord *data_word = data.ptr_data;    printf("%s %d", data_word->word, data_word->counter);}void free_word(data_union data) {    DataWord *data_word = data.ptr_data;    free(data_word->word);    free(data_word);}int cmp_word(data_union a, data_union b) {    return strcmp( ((DataWord *)a.ptr_data)->word, ((DataWord *)b.ptr_data)->word );}size_t hash_word(data_union data, size_t size) {	int s = 0;	DataWord *dw = (DataWord*)data.ptr_data;	char *p = dw->word;	while (*p) {		s += *p++;	}	return hash_base(s, size);}void modify_word(data_union *data) {    ((DataWord *)data->ptr_data)->counter++;}data_union create_data_word(void *value) {    char * val = (char *)value;    char *word = malloc(sizeof(char)*strlen(val)+1);    for (int i=0; i<strlen(val); i++){        *(word+i) = tolower(*(val+i));    }    *(word+strlen(val)) = '\0';    data_union new_union;    DataWord *dt = malloc(sizeof(DataWord));    dt->word = word;    dt->counter = 1;    new_union.ptr_data = dt;    return new_union;}// read text, parse it to words, and insert these words to the hashtablevoid stream_to_ht(hash_table *p_table, FILE *stream) {    char delimits[] = " \r\t\n.,?!:;-";    char *p;    char buf[BUFFER_SIZE];    while(fgets(buf,BUFFER_SIZE,stream)) {        p = strtok(buf, delimits);        while(p) {            //printf("%s ", word);            data_union data = create_data_word(p);            //printf("%s ", p);            insert_element(p_table, &data);            p = strtok(NULL,delimits);        }    }}// test primitive type listvoid test_ht(hash_table *p_table, int n) {	char op;	data_union data;	for (int i = 0; i < n; ++i) {		scanf(" %c", &op);//		p_table->create_data(&data);		data = p_table->create_data(NULL); // should give the same result as the line above		switch (op) {			case 'r':				remove_element(p_table, data);				break;			case 'i':				insert_element(p_table, &data);				break;			default:				printf("No such operation: %c\n", op);				break;		}	}}int main(void) {	int to_do, n;	size_t index;	hash_table table;	char buffer[BUFFER_SIZE];	data_union data;	scanf ("%d", &to_do);	switch (to_do) {		case 1: // test integer hash table			scanf("%d %zu", &n, &index);			init_ht(&table, 4, dump_int, create_int, NULL, cmp_int, hash_int, NULL);			test_ht(&table, n);			printf ("%zu\n", table.size);			dump_list(&table, index);			break;		case 2: // test char hash table			scanf("%d %zu", &n, &index);			init_ht(&table, 4, dump_char, create_char, NULL, cmp_char, hash_char, NULL);			test_ht(&table, n);			printf ("%zu\n", table.size);			dump_list(&table, index);			break;		case 3: // read words from text, insert into hash table, and print			scanf("%s", buffer);			init_ht(&table, 8, dump_word, create_data_word, free_word, cmp_word, hash_word, modify_word);			stream_to_ht(&table, stdin);			printf ("%zu\n", table.size);			data = table.create_data(buffer);			ht_element *e = get_element(&table, &data);			if (e) table.dump_data(e->data);			if (table.free_data) table.free_data(data);			break;		default:			printf("NOTHING TO DO FOR %d\n", to_do);			break;	}	free_table(&table);	return 0;}