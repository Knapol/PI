#include <stdio.h>#include <stdlib.h>#include <string.h>#define MAX_REL_SIZE 100#define MAX_RANGE 100typedef struct {	int first;	int second;} pair;void bubbleSort(int tab[], int n){    for (int i=0; i<n-1; i++){        for (int j=0; j<n-i-1; j++){            if(tab[j] > tab[j+1]) {                int tmp = tab[j];                tab[j]=tab[j+1];                tab[j+1]=tmp;            }        }    }}// Case 1:// The relation R is reflexive if xRx for every x in Xint is_reflexive(pair* relation, int n){    int num;    for (int i=0; i<2*n; i++){        if (i%2==0)            num = relation[i/2].first;        else            num = relation[i/2].second;        int flag = 0;        for (int j=0; j<n; j++){            if (relation[j].first == num && relation[j].second == num) {                flag = 1;                break;            }        }        if (flag == 0)            return 0;    }    return 1;}// The relation R on the set X is called irreflexive// if xRx is false for every x in Xint is_irreflexive(pair* relation, int n){    int num;    for (int i=0; i<2*n; i++){        if (i%2==0)            num = relation[i/2].first;        else            num = relation[i/2].second;        for (int j=0; j<n; j++){            if (relation[j].first == num && relation[j].second == num)                return 0;        }    }    return 1;}// A binary relation R over a set X is symmetric if:// for all x, y in X xRy <=> yRxint is_symmetric(pair* relation, int n){    int a, b;    for (int i=0; i<n; i++){        a = relation[i].first;        b = relation[i].second;        int flag = 0;        for (int j=0; j<n; j++){            if (relation[j].first == b && relation[j].second == a){                flag = 1;                break;            }        }        if (flag == 0)            return 0;    }    return 1;}// A binary relation R over a set X is antisymmetric if:// for all x,y in X if xRy and yRx then x=yint is_antisymmetric(pair* relation, int n){    int a, b;    for (int i=0; i<n; i++){        a = relation[i].first;        b = relation[i].second;        if (a!=b)            for (int j=0; j<n; j++){                if (relation[j].first == b && relation[j].second == a){                    return 0;                }            }    }    return 1;}// A binary relation R over a set X is asymmetric if:// for all x,y in X if at least one of xRy and yRx is falseint is_asymmetric(pair* relation, int n){    int a, b;    for (int i=0; i<n; i++){        a = relation[i].first;        b = relation[i].second;        for (int j=0; j<n; j++) {            if (relation[j].first == b && relation[j].second == a) {                return 0;            }        }    }    return 1;}// A homogeneous relation R on the set X is a transitive relation if:// for all x, y, z in X, if xRy and yRz, then xRzint is_transitive(pair* relation, int n){    int a, b, c;    for (int i=0; i<n; i++){        a = relation[i].first;        b = relation[i].second;        for (int j=0; j<n; j++){            if (relation[j].first == b) {                c = relation[j].second;                int flag = 0;                for (int k=0; k<n; k++){                    if (relation[k].first == a && relation[k].second == c){                        flag = 1;                        break;                    }                }                if (flag == 0)                    return 0;            }        }    }    return 1;}// Case 2:// A partial order relation is a homogeneous relation that is// reflexive, transitive, and antisymmetricint is_partial_order(pair* relation, int n){    if (is_reflexive(relation, n) && is_antisymmetric(relation, n) && is_transitive(relation, n))        return 1;    return 0;}int get_domain(pair* relation, int n, int* dz){    int dom[MAX_REL_SIZE];    int counter = 0;    for (int i=0; i<n; i++){        dom[counter++]=relation[i].first;        dom[counter++]=relation[i].second;    }    bubbleSort(dom, counter);    dz[0] = dom[0];    int size_dz = 1;    for (int i=0; i<counter; i++){        if (dz[size_dz-1] != dom[i])            dz[size_dz++]=dom[i];    }    return size_dz;}// Relation R is connected if for each x, y in X:// xRy or yRx (or both)int is_connected(pair* rel, int n){    int dom[MAX_REL_SIZE];    int size_dom = get_domain(rel, n, dom);    int a,b;    for (int i=0; i<size_dom-1; i++){        a = dom[i];        for (int j=i; j<size_dom; j++){            b = dom[j];            int flag = 0;            for (int k=0; k<n; k++){                if ((rel[k].first == a && rel[k].second == b) || (rel[k].first == b && rel[k].second == a)){                    flag = 1;                    break;                }            }            if (flag == 0)                return 0;        }    }    return 1;}// A total order relation is a partial order relation that is connectedint is_total_order(pair* relation, int n){    if (is_partial_order(relation, n) && is_connected(relation, n))        return 1;    return 0;}int find_max_elements(pair* rel, int n, int* max){    int dom[MAX_REL_SIZE];    int size_dom = get_domain(rel, n, dom);    int a,b, counter = 0;    for (int i=0; i<size_dom; i++){        a = dom[i];        int is_max = 1;        for (int k=0; k<n; k++){            if (rel[k].first == a && rel[k].second != a){                is_max = 0;                break;            }        }        if (is_max == 1){            max[counter]=a;            counter++;        }    }    return counter;}int find_min_elements(pair* rel, int n, int* min){    int dom[MAX_REL_SIZE];    int size_dom = get_domain(rel, n, dom);    int a,b, counter = 0;    for (int i=0; i<size_dom; i++){        a = dom[i];        int is_min = 1;        for (int k=0; k<n; k++){            if (rel[k].first != a && rel[k].second == a){                is_min = 0;                break;            }        }        if (is_min == 1){            min[counter]=a;            counter++;        }    }    return counter;}// Case 3:int composition (pair* rel1, int n1, pair* rel2, int n2, pair* c_rel){    int comp_size=0;    int a, b;    for (int i=0; i<n1; i++){        a = rel1[i].first;        for (int j=0; j<n2; j++){            if (rel1[i].second == rel2[j].first){                int add = 1;                b = rel2[j].second;                for (int k=0; k<comp_size; k++){                    if (c_rel[k].first == a && c_rel[k].second == b){                        add = 0;                        break;                    }                }                if (add==1) {                    c_rel[comp_size].first = a;                    c_rel[comp_size].second = b;                    comp_size++;                }            }        }    }    return comp_size;}// Comparator for pairint cmp_pair (const void *a, const void *b) {}int insert_int (int *tab, int n, int new_element) {}// Add pair to existing relation if not already thereint add_relation (pair *tab, int n, pair new_pair) {    for (int i=0; i<n; i++){        if (tab[i].first == new_pair.first && tab[i].second == new_pair.second)            break;    }    tab[n]=new_pair;    return n+1;}// Read number of pairs, n, and then n pairs of intsint read_relation(pair *relation) {    int n;    scanf("%d", &n);    for (int i=0; i<n; i++){        pair new;        scanf("%d %d", &new.first, &new.second);        relation[i]=new;    }    return n;}void print_int_array(int *array, int n) {    printf("%d \n",n);    for (int i=0; i<n; i++){        printf("%d ",array[i]);    }    printf("\n");}int main(void) {	int to_do;	pair relation[MAX_REL_SIZE];	pair relation_2[MAX_REL_SIZE];	pair comp_relation[MAX_REL_SIZE];	int domain[MAX_REL_SIZE];	int max_elements[MAX_REL_SIZE];	int min_elements[MAX_REL_SIZE];	scanf("%d",&to_do);	int size = read_relation(relation);	int ordered, size_2, n_domain;	switch (to_do) {		case 1:			printf("%d ", is_reflexive(relation, size));			printf("%d ", is_irreflexive(relation, size));			printf("%d ", is_symmetric(relation, size));			printf("%d ", is_antisymmetric(relation, size));			printf("%d ", is_asymmetric(relation, size));			printf("%d\n", is_transitive(relation, size));			break;		case 2:			ordered = is_partial_order(relation, size);			n_domain = get_domain(relation, size, domain);			printf("%d %d\n", ordered, is_total_order(relation, size));			print_int_array(domain, n_domain);			if (!ordered) break;			int no_max_elements = find_max_elements(relation, size, max_elements);			int no_min_elements = find_min_elements(relation, size, min_elements);			print_int_array(max_elements, no_max_elements);			print_int_array(min_elements, no_min_elements);			break;		case 3:			size_2 = read_relation(relation_2);			printf("%d\n", composition(relation, size, relation_2, size_2, comp_relation));			break;		default:			printf("NOTHING TO DO FOR %d\n", to_do);			break;	}	return 0;}