#include <stdio.h>#include <stdlib.h>#include <string.h>#include <stddef.h>#define TAB_SIZE  1000#define BUF_SIZE  1000int get(int cols, int row, int col, const int *A) {    return *(A+row*cols+col);}void set(int cols, int row, int col, int *A, int value) {    *(A+row*cols+col)=value;}void prod_mat(int rowsA, int colsA, int colsB, int *A, int *B, int *AB) {    for (int i=0; i<rowsA; i++){        for (int j=0; j<colsB; j++){            int value = 0;            for (int k=0; k<colsA; k++)                value += get(colsA, i, k, A)*get(colsB, k, j, B);            set(colsB, i, j, AB, value);        }    }}void read_mat(int rows, int cols, int *t) {    for (int i=0; i<rows; i++){        for(int j=0; j<cols; j++){            scanf("%d", (t+i*cols+j));        }    }}void print_mat(int rows, int cols, int *t) {    for (int i=0; i<rows; i++){        for(int j=0; j<cols; j++){            printf("%d ", *(t+i*cols+j));        }        printf("\n");    }}int read_char_lines(char *array[]) {    int c;    int lines = 0;    int index = 0;    array[lines] = (char*)malloc(BUF_SIZE*sizeof(char));    for(;;){        c = getc(stdin);        if (c == EOF)            return lines;        if (c == '\n'){            *(array[lines]+index) = '\0';            lines++;            array[lines] = (char*)malloc(BUF_SIZE*sizeof(char));            index = 0;            continue;        }        *(array[lines]+index) = c;        index++;    }}void write_char_line(char *array[], int n) {    printf("%s", array[n]);}void delete_lines(char *array[]) {    int i=0;    while (*(array+i) != NULL){        free(*(array+i));        i++;    }}int read_int_lines_cont(int *ptr_array[]) {    int c;    int lines = 1;    int *tab = *ptr_array;    for(;;){        c = fgetc(stdin);        if (c == EOF)            return lines;        if (c == '\n'){            ptr_array[lines]=tab;            lines++;            continue;        }        *tab = c;        tab = tab + 1;    }}void write_int_line_cont(int *ptr_array[], int n) {    for(int *i=ptr_array[n]; i<ptr_array[n+1]; i++){        printf("%c", *i);    }}typedef struct {	int *values;	int len;	double average;} line_type;double get_average(int *values, int n){    int minus = 1;    int num=0;    int counter = 0;    double av = 0;    for (int i=0; i<n; i++){        if (values[i]!=' '){            if (values[i]=='-'){                minus = -1;            }            else{                num = num*10+(values[i]-48);            }        }        else{            counter++;            av += minus*num;            minus = 1;            num = 0;        }    }    counter++;    av += minus*num;    return av/counter;}int read_int_lines(line_type lines_array[]) {    int c;    int lines = 0;    int index = 0;    lines_array[lines].values = (int*)malloc(BUF_SIZE*sizeof(int));    lines_array[lines].len = 0;    for(;;){        c = getc(stdin);        if (c == EOF)            return lines;        if (c == '\n'){            lines_array[lines].len = index;            lines_array[lines].average = get_average(lines_array[lines].values,lines_array[lines].len);            lines++;            lines_array[lines].values = (int*)malloc(BUF_SIZE*sizeof(int));            lines_array[lines].len = 0;            index = 0;            continue;        }        *(lines_array[lines].values + index) = c;        index++;    }}void write_int_line(line_type lines_array[], int n) {    for(int *i=lines_array[n].values; i<lines_array[n].values+lines_array[n].len; i++){        printf("%c", *i);    }    printf("\n%f",lines_array[n].average);}void delete_int_lines(line_type array[], int line_count) {    for (int i=0; i<line_count; i++){        free(array[i].values);    }}int cmp (const void *a, const void *b) {    const line_type *line1 = (line_type *)a;    const line_type *line2 = (line_type *)b;    if (line1 -> average > line2 -> average)        return 1;    if (line1 -> average < line2 -> average)        return -1;    return 0;}void sort_by_average(line_type lines_array[], int line_count) {    qsort(lines_array, line_count, sizeof(line_type), cmp);}typedef struct {	int r, c, v;} triplet;int read_sparse(triplet *triplet_array, int n_triplets) {    for(int i=0; i<n_triplets; i++){        fscanf(stdin, "%d %d %d", &(triplet_array[i].r),&(triplet_array[i].c),&(triplet_array[i].v));    }    return n_triplets;}int cmp_triplets(const void *t1, const void *t2) {    triplet *triplet1 = (triplet *)t1;    triplet *triplet2 = (triplet *)t2;    int cmp1 = triplet1 -> r - triplet2 -> r;    if (cmp1 != 0)        return cmp1;    int cmp2 = triplet1 -> c - triplet2 -> c;    return cmp2;}void make_CSR(triplet *triplet_array, int n_triplets, int rows, int *V, int *C, int *R) {    qsort(triplet_array, n_triplets, sizeof(triplet), cmp_triplets);    int row = 0;    for (int i=0; i<n_triplets; i++) {        V[i] = triplet_array[i].v;        C[i] = triplet_array[i].c;    }    R[row]=0;    row++;    for (int i=1; i<rows; i++){        if (triplet_array[i].r != triplet_array[i-1].r){            R[row] = i;            row++;        }        else{            R[row] = R[row-1];            row++;        }    }    R[row]=n_triplets;}void multiply_by_vector(int rows, const int *V, const int *C, const int *R, const int *x, int *y) {    for (int i=0; i<rows; i++){        y[i]=0;        for (int j=R[i]; j<R[i+1]; j++){            y[i]=y[i]+V[j]*x[C[j]];        }    }}void read_vector(int *v, int n) {    for (int i=0; i<n; i++){        fscanf(stdin, "%d", &v[i]);    }}void write_vector(int *v, int n) {    for (int i=0; i<n; i++){        printf("%d ", v[i]);    }    printf("\n");}int read_int() {	char c_buf[BUF_SIZE];	fgets(c_buf, BUF_SIZE, stdin);	return (int)strtol(c_buf, NULL, 10);}int main(void) {	int to_do = read_int();	int A[TAB_SIZE], B[TAB_SIZE], AB[TAB_SIZE];	int n, lines_counter, rowsA, colsA, rowsB, colsB;	int rows, cols, n_triplets;	char *char_lines_array[TAB_SIZE] = { NULL };	int continuous_array[TAB_SIZE];	int *ptr_array[TAB_SIZE];	triplet triplet_array[TAB_SIZE];	int V[TAB_SIZE], C[TAB_SIZE], R[TAB_SIZE];	int x[TAB_SIZE], y[TAB_SIZE];	line_type int_lines_array[TAB_SIZE];	switch (to_do) {		case 1:			scanf("%d %d", &rowsA, &colsA);			read_mat(rowsA, colsA, A);			scanf("%d %d", &rowsB, &colsB);			read_mat(rowsB, colsB, B);			prod_mat(rowsA, colsA, colsB, A, B, AB);			print_mat(rowsA, colsB, AB);			break;		case 2:			n = read_int() - 1; // we count from 1 :)			ptr_array[0] = continuous_array;			read_int_lines_cont(ptr_array);			write_int_line_cont(ptr_array, n);			break;		case 3:			n = read_int() - 1;			read_char_lines(char_lines_array);			write_char_line(char_lines_array, n);			delete_lines(char_lines_array);			break;		case 4:			n = read_int() - 1;			lines_counter = read_int_lines(int_lines_array);			sort_by_average(int_lines_array, lines_counter);			write_int_line(int_lines_array, n);			delete_int_lines(int_lines_array, lines_counter);			break;		case 5:			scanf("%d %d %d", &rows, &cols, &n_triplets);			n_triplets = read_sparse(triplet_array, n_triplets);			read_vector(x, cols);			make_CSR(triplet_array, n_triplets, rows, V, C, R);			multiply_by_vector(rows, V, C, R, x, y);			write_vector(V, n_triplets);			write_vector(C, n_triplets);			write_vector(R, rows + 1);			write_vector(y, rows);			break;		default:			printf("NOTHING TO DO FOR %d\n", to_do);			break;	}	return 0;}