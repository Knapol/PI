#include <stdio.h>#include <stdlib.h>#include <math.h>#include <string.h>#define SIZE 40#define TEST 1    // 1 - dla testow,  0 - dla oceny automatycznejvoid read_vec(double x[], size_t n) {  for(size_t i=0; i<n; ++i)  scanf("%lf",x++);}void print_vec(const double x[], size_t n) {  for(size_t i=0; i<n; ++i) printf("%.4f ",x[i]);  printf("\n");}void read_mat(double A[][SIZE], size_t m, size_t n) {  for(size_t i=0; i<m; ++i) {    for(size_t j=0; j<n; ++j)  scanf("%lf",&A[i][j]);  }}void print_mat(const double A[][SIZE], size_t m, size_t n) {  for(size_t i=0; i<m; ++i) {    for(size_t j=0; j<n; ++j)  printf("%.4f ",A[i][j]);    printf("\n");  }}// 5.2.1 Triangularyzacja, wyznacznik i rozwiazanie Ax=b dla  macierzy kwadratowej.// Wersja rozszerzona: Wybor wiersza z maksymalna waroscia |elementu glownego|// Przy wymianie wierszy nalezy zastosowac wetor permutacji indeksow wierszy.// Jezeli maksymalna wartosc |elementu glownego| < eps, to wyznacznik = 0.// Zwraca wyznacznik det. Jezeli =0,  to triangularyzacja moze byc niedokonczona.// Jezeli wyznacznik != 0, i b,x != NULL,// to w wektorze x umieszcza rozwiazanie ukladu rownan Ax=b.double gauss(double A[][SIZE], const double b[], double x[], size_t n, double eps) {    int index[n];    double result[n];    double determinant;    for (int i=0; i<n; i++){        index[i]=i;        result[i]=b[i];    }    for (int i=0; i<n; i++){        int change_rows = 0;        double max = fabs(A[index[i]][i]);        int max_ind = i;        for (int j=i+1; j<n; j++) {            double tmp = fabs(A[index[j]][i]);            if (tmp > max){                max = tmp;                max_ind = j;            }        }        if (max_ind != i)            change_rows = 1;        int tmp = index[i];        index[i]=index[max_ind];        index[max_ind]=tmp;        if (fabs(A[index[i]][i])<eps) {            determinant = 0;            return determinant;        }        for (int j=i+1; j<n; j++) {            double r = A[index[j]][i]/A[index[i]][i];            for (int k=i; k<n; k++){                A[index[j]][k]-=r*A[index[i]][k];            }            result[index[j]] -= r*result[index[i]];        }        if (i==0)            determinant=A[index[i]][i];        else            determinant*=A[index[i]][i];        if (change_rows==1)            determinant *= (-1);    }    for (int i=n-1; i>=0; i--){        int counter = 0;        double sum = 0;        for (int j=n-1; j>i; j--){            sum += A[index[i]][j]*x[n-1-counter];            counter+=1;        }        x[i]=(result[index[n-1-counter]]-sum)/A[index[i]][i];    }    return determinant;}// 5.2.2// Zwraca wyznacznik i w tablicy B macierz odwrotna (jezlei wyznacznik != 0)// Jezeli maksymalna bezwzgledna wartosc elementu glownego < eps,// to funkcja zwraca wartosc wyznacznika det = 0.// Funkcja zmienia wartosci takze w tablicy A.double matrix_inv(double A[][SIZE], double B[][SIZE], size_t n, double eps) {    double pom[n][n];    int index[n];    double determinant;    for (int i=0; i<n; i++){        for (int j=0; j<n; j++){            if (i == j)                pom[i][j] = 1;            else                pom[i][j] = 0;        }        index[i]=i;    }    for (int i=0; i<n; i++){        int change_rows = 0;        double max = fabs(A[index[i]][i]);        int max_ind = i;        for (int j=i+1; j<n; j++) {            double tmp = fabs(A[index[j]][i]);            if (tmp > max){                max = tmp;                max_ind = j;            }        }        if (max_ind != i)            change_rows = 1;        int tmp = index[i];        index[i]=index[max_ind];        index[max_ind]=tmp;        if (fabs(A[index[i]][i])<eps) {            determinant = 0;            return determinant;        }        for (int j=0; j<n; j++) {            if (j!=i) {                double r = A[index[j]][i] / A[index[i]][i];                for (int k = 0; k < n; k++) {                    A[index[j]][k] -= r * A[index[i]][k];                    pom[index[j]][k] -= r * pom[index[i]][k];                }            }        }        /*printf("\n");        for (int a=0; a<n; a++) {            for (int b = 0; b < n; b++) {                printf("%f ", A[index[a]][b]);            }            printf(" | ");            for (int b = 0; b < n; b++) {                printf("%f ", pom[index[a]][b]);            }            printf("\n");        }        printf("\n");*/        if (i==0)            determinant=A[index[i]][i];        else            determinant*=A[index[i]][i];        if (change_rows==1)            determinant *= (-1);        double d = 1/A[index[i]][i];        for (int k = 0; k < n; k++) {            A[index[i]][k] *= d;            pom[index[i]][k] *= d;        }    }    for (int i=0; i<n; i++){        for (int j=0; j<n; j++){            B[i][j]=pom[index[i]][j];        }    }    return determinant;}int main(void) {    double A[SIZE][SIZE], B[SIZE][SIZE], C[SIZE][SIZE];    double b[SIZE], x[SIZE], det, eps = 1.e-13;	int to_do;	size_t m,n,p,q;	if(TEST) printf("Wpisz nr zadania ");	scanf ("%d", &to_do);	switch (to_do) {    case 1:      if(TEST) printf("Wpisz liczbe wierszy i kolumn mac. kwadratowej: ");      scanf("%d", &n);      if(TEST) printf("Wpisz macierz A (wierszami): ");      read_mat(A,n,n);      if(TEST) printf("Wpisz wektor b: ");      read_vec(b,n);      det = gauss(A, b, x, n, eps);      printf("%.4f\n",det);      if(det) print_vec(x,n);      break;    case 2:      if(TEST) printf("Wpisz rozmiar macierzy n = ");      scanf("%d",&n);      if(TEST) printf("Wpisz elementy macierzy (wierszami): ");      read_mat(A,n,n);      det = matrix_inv(A,B,n,eps);      printf("%.4f\n",det);      if(det) print_mat(B,n,n);      break;    default:      printf("NOTHING TO DO FOR %d\n", to_do);	}	return 0;}